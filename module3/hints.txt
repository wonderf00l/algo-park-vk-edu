Ex 1 test:

создаем list граф, заполняем
создаем matrxi граф через list граф
проверяем что стурктура графа ткакая же
последовательно конструируем графы через предыдущие

структура должна остаться неизменной



set на хеш-таблице - std::unordered set

set на красно-черных деревьях - std::set

ПОЛЕЗНОЕ ДЛЯ ДЕБАГА В VSCODE:
RUN -- ADD CONG -- gdb (launch) -- для дебага уже собранного файла, то есть цель build не создается, launch.json только для дебага уже собранного exe
в конфиге launch.json выбираем нужный executable
${workspaceFolder} - папка, которая открыта сейчас в vscode

собираем exe со всеми флажками И НЕ ЗАБЫВАЕМ ФЛАГ -g для получения возможности дебага и вывода отладочной информации

если хотим собирать по кнопке, то выбрием run c++ file, создается tasks.json, настраиваем сборку: включаем все исходники, заголовки, флажки и тп

в алгоритме Дейкстры также используется bfs, но теперь очередь с приоритетом(сравнение по расстоянию от корневой вершины)

ребра не могут быть отрицательными

стартуем от корня(пара (0, 0)), рассматриваем соседей и заполняем пары (d[v], v) (d[v] - вес ребра до вершины v, d[v+1] увеличивается путем прибавления к d[v] веса ребра до v + 1 ), попаем топ кучи(пара с наименьшим 1-ым параметром(расстоянием до корня)), смотрим соседей вершины, если встретились уже расммотренные соседи и расстояние через текущую
вершину меньше(более выгодный путь), то заменяем пару для такой вершины на новую(пара с меньшим расстоянием - делается через использование std::set<std::pair<d[v], v>>, основанного на красно-черном дереве, для изменения делаем erase old - insert new)
снова достаем вершниы с наименьшим приоритетом, и так пока очередь не опустеет

СЛОЖНОСТЬ

V*logV - добавление вершин в очередь с приоритетом(на основе двоичной кучи или сбалансированного красно-черного дерева)
E*logV - релаксация ребер(обновление веса ребра на наименьший)

ИТОГО:
по времени -- O(logV*(E + V))
по памяти - O(V)


№4

std::reverse

восьминашки: max кол-во элементов в очереди(состояний поля) - 9! -- то есть в худшем случае модем хранить в памяти буфер такого размера

и путем перебора возможных состояний придем к искомому упорядоченному

в случае пятнашек перестановок 16! - поэтому для экономии памяти используется алгоритм A* вместо стандартного bfs

Алгоритм A* 

При релаксации ребра в качестве приоритета прописываем не обновленный d[v], а d[v] + h(v)

d[v] - min стоимость пути из начальной вершины в V
h(v) - эвристическое приближение стоимости пути от V до финиша

Необходимый критерий для эвристики:
монотонность -- для любой вершины v1 и ее потомка v2 |h(v1) - h(v2)| <= wight(v1, v2)

достаточное:
допустимость -- для любой вершины h(v) <= кратчайшему пути от v до цели
(то есть эвристика - теоретический, наиболее оптимистичный вариант попадания из текущей вершины в конечную)