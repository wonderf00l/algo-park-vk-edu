E - E - E - E - K1 -
    E

        если хеш от ключа совпал,
    идем дальше осгласно алгоритму пробирования

            E -
        E - E - K1 - K2 - K3 -
        E

            удаляем K2 :

    посчитали хеш -
    наткунлись на K1,
    сравнили ключи(нужен компаратор для ключей),
    идем дальше до совпадения - дошли - удалили -
        пометили D

        нужна пометка,
    чтобы осуществить полноценный поиск элемента,
    при поиске скипаем D

        E
        - E - E - K1 - D - K3 -
        E

        ищем,
    пока кол - во шагов<кол - ва элементов

                                  после проверки,
                        что ключа нет в таблцие, вставляем в самый первый D, если таких нет,
                        то в E

                            используем структуры,
                        а не указатели на структуры

                                    меняем простые числа в хешерах

                                        S0-- S0 *
                                A +
                            S1--(S0 *A + S1) * A + S2--((SO * A + S1) * A + S2) * A +
                            S3

                                Первое требование  − на p : p> max{si}
                   .Если это так,
    то хеш от строки без взятия по модулю(по сути, значение многочлена в некоторой точке  − отсюда и название полиномиальное
                                                       хеширование)  − инъекция.А вот если брать p меньше,
    чем max{si},
    то коллизии могут появиться ещё на этапе подсчёта.

    Далее,
    мы хотим выбрать такие p и M,
    чтобы минимизировать вероятность коллизии.В частности, мы хотим минимизировать количество таких остатков,
    которые не могут быть хешом никакой строки.Давайте тогда возьмём взаимнопростые p и M.(
        если a и M - не взаимно простые,
        то при рассмотрении конкретного произведения с конкретным битом остаток от деления бдует 0 -- >
            не бдует учитываться вклад в разницу хешей,
        вносимый конкретным символом)
